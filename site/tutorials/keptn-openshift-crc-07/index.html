
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Keptn on OpenShift with Code Ready Containers</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-133584243-1"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="keptn-openshift-crc-07"
                  title="Keptn on OpenShift with Code Ready Containers"
                  environment="web"
                  feedback-link="https://github.com/keptn/tutorials/tree/master/site/tutorials">
    
      <google-codelab-step label="Welcome" duration="2">
        <p>In this tutorial you&#39;ll get a full tour on how to run Keptn on Code Ready Containers.<br><a href="https://developers.redhat.com/products/codeready-containers/overview" target="_blank">Code Ready Containers</a> gets you up and running with an OpenShift cluster on your local machine in minutes.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Resources" duration="5">
        <p>We have provided some helper scripts and files for you to make the tutorial more frictionless.</p>
<p>Download the resources for this tutorial via git:</p>
<pre><code>git clone --branch release-0.1.0 https://github.com/keptn-sandbox/openshift-crc-tutorial

cd openshift-crc-tutorial/resources
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Get Code Ready Containers" duration="10">
        <p>For running <a href="https://developers.redhat.com/products/codeready-containers/overview" target="_blank">Code Ready Containers</a> a machine with at least 16 GB of RAM is recommended.</p>
<ol type="1">
<li>Download CRC from this website into the current folder that we have created inthe previous step: <a href="https://developers.redhat.com/products/codeready-containers/download" target="_blank">https://developers.redhat.com/products/codeready-containers/download</a><br>There are versions available for Mac OS, Linux, and Windows. This tutorial has been tested on version TODO and the instructions here are for the Mac/Linux version.</li>
<li>Copy your pull secret to the current folder in a file called <code>pull-secret.txt</code>.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Install CodeReady Containers" duration="10">
        <ol type="1">
<li>Define the CodeReady Container version and your operating system - please adjust those variables to fit your environment! Execute these commands depending on your environment.<pre><code>export OS=macos
export CRCVERSION=1.14.0
</code></pre>
For Linux that might look like this.<pre><code>export OS=linux
export CRCVERSION=1.14.0
</code></pre>
</li>
<li>Edit <code>crc.sh</code> if you want to configure the memory and CPU cores available to CodeReady Containers.</li>
<li>Execute the setup script<pre><code>./crc.sh
</code></pre>
</li>
<li>Once finished, the script will provide you with some output:<pre><code>This will install OpenShift 4.5, display the login info and open a browser window with the OpenShift console.
INFO To access the cluster, first set up your environment by following &#39;crc oc-env&#39; instructions
INFO Then you can access it by running &#39;oc login -u developer -p developer https://api.crc.testing:6443&#39;
INFO To login as an admin, run &#39;oc login -u kubeadmin -p yourpassword https://api.crc.testing:6443&#39;
INFO
INFO You can now run &#39;crc console&#39; and use these credentials to access the OpenShift web console
Started the OpenShift cluster
WARN The cluster might report a degraded or error state. This is expected since several operators have been disabled to lower the resource usage. For more information, please consult the documentation
Opening the OpenShift Web Console in the default browser...
</code></pre>
</li>
<li>From the previous output, we still need to execute some commands. To access the cluster, first set up your environment by following â€˜crc oc-env&#39; instructions.<pre><code>crc oc-env
eval $(crc oc-env)
</code></pre>
</li>
<li>Login as an <code>admin</code> with the command that from the log output above. Please make sure to use the correct password that you see on your own screen.<pre><code>oc login -u kubeadmin -p yourpassword https://api.crc.testing:6443
</code></pre>
</li>
</ol>
<aside class="warning"><p>Depending on your machine, it might take a while (3-5 minutes) for CRC to ready and accept your login request. Please be patient.</p>
</aside>
<h2 is-upgraded>Other options to run CRC</h2>
<p>If you want to run it on a different environment than you local machine, check out these additional resources.</p>
<aside class="warning"><p>Please note that the Keptn team is not the author of these resources. If you run into any issues please reach out to the original authors.</p>
</aside>
<p><a href="https://kxr.me/2019/08/17/openshift-4-upi-install-libvirt-kvm/" target="_blank">OpenShift 4 UPI Installation on Libvirt/KVM</a></p>
<p><a href="https://fedoramagazine.org/codeready-containers-complex-solutions-on-openshift-fedora/" target="_blank">CodeReady Containers: complex solutions on OpenShift + Fedora</a></p>
<p>If you want to run it on a VM in GCP, please make sure nested virtualization is enabled. <a href="https://cloud.google.com/compute/docs/instances/enable-nested-virtualization-vm-instances" target="_blank">Follow this official guide</a> if not yet enabled.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Install OpenShift service mesh" duration="5">
        <p>Now we are going to install the OpenShift serivce mesh that is needed for our tutorial into the CRC cluster.</p>
<p>The script that is provided will create the following resources:</p>
<ul>
<li>Install Kiali, Jaeger and Service Mesh Operators</li>
<li>Deploy the Service Mesh control plane in istio-system.</li>
<li>Create the Service Mesh member roll.</li>
</ul>
<ol type="1">
<li>Execute the script:<pre><code>./mesh.sh 
</code></pre>
</li>
<li>Verify that all pod in the <code>istio-namespace</code> are running (might take a while).<pre><code>oc get pods
</code></pre>
You should see a similar result:<pre><code>NAME                                      READY   STATUS    RESTARTS   AGE
grafana-6787dc695-b9srg                   2/2     Running   0          56s
istio-citadel-6f9b74b754-2npp9            1/1     Running   0          3m43s
istio-egressgateway-64ffbdb8c8-kbqbl      1/1     Running   0          91s
istio-galley-7c6fb78655-ntbd2             1/1     Running   0          2m31s
istio-ingressgateway-6c77fdbbd4-hxtch     1/1     Running   0          90s
istio-pilot-7bf87fc66c-h5kmd              2/2     Running   0          109s
istio-policy-55b9c86c8c-24szc             2/2     Running   0          2m16s
istio-sidecar-injector-66fd9459d9-2qk5s   1/1     Running   0          83s
istio-telemetry-859854d88b-2p9tb          2/2     Running   0          2m15s
jaeger-64d858c8c5-44cfj                   2/2     Running   0          2m30s
prometheus-6864b4b755-tk7q2               2/2     Running   0          3m24s
</code></pre>
</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Install Keptn" duration="0">
        <p>Let us know install Keptn on our local OpenShift/CRC cluster.</p>
<ol type="1">
<li>Download the Keptn CLI:<pre><code>curl -sL https://get.keptn.sh | sudo -E bash
</code></pre>
</li>
<li>Install Keptn into the cluster via the CLI:<pre><code>keptn install --use-case=continuous-delivery --platform=openshift
</code></pre>
</li>
<li>TODO verify if new resource limits are required</li>
<li>Expose the API endpoint of Keptn to be able to connect to it.<pre><code>oc expose svc api-gateway-nginx
</code></pre>
</li>
<li>Now let&#39;s connect the Keptn CLI to the Keptn installation.<pre><code>export KEPTN_ENDPOINT=http://api-gateway-nginx-keptn.apps-crc.testing/api
export KEPTN_API_TOKEN=$(oc get secret keptn-api-token -n keptn -ojsonpath={.data.keptn-api-token} | base64 --decode)
  
keptn auth --endpoint=$KEPTN_ENDPOINT --api-token=$KEPTN_API_TOKEN
</code></pre>
</li>
<li>Get the credentials for the bridge<pre><code>keptn configure bridge --output
</code></pre>
</li>
</ol>
<p>Now go ahead and open a browser to login.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Setup Dynatrace" duration="7">
        <p>For enabling the Keptn Quality Gates and for production monitoring, we are going to use Dynatrace as the data provider. Therefore, we are going to setup Dynatrace in our Kubernetes cluster to have our sample application monitored and we can use the monitoring data for both the basis for evaluating quality gates as well as a trigger to start self-healing.</p>
<aside class="special"><p>You have to bring your own Dynatrace tenant</p>
</aside>
<p>If you don&#39;t have a Dynatrace tenant yet, sign up for a <a href="https://www.dynatrace.com/trial/" target="_blank">free trial</a> or a <a href="https://www.dynatrace.com/developer/" target="_blank">developer account</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Gather Dynatrace tokens" duration="6">
        <ol type="1">
<li>Create a Dynatrace API TokenLog in to your Dynatrace tenant and go to <strong>Settings &gt; Integration &gt; Dynatrace API</strong>. Then, create a new API token with the following permissions:<ul>
<li>Access problem and event feed, metrics and topology</li>
<li>Read log content</li>
<li>Read configuration</li>
<li>Write configuration</li>
<li>Capture request data</li>
<li>Read metrics using API V2</li>
<li>Read entities using API V2</li>
</ul>
Take a look at this screenshot to double check the right token permissions for you.<img alt="Dynatrace API Token" src="img/2c13d90861689a.png"></li>
<li>Create a Dynatrace PaaS TokenIn your Dynatrace tenant, go to <strong>Settings &gt; Integration &gt; Platform as a Service</strong>, and create a new PaaS Token.</li>
<li>Store your credentials in a Kubernetes secret by executing the following command. The <code>DT_TENANT</code> has to be set according to the appropriate pattern:<ul>
<li>Dynatrace SaaS tenant (this format is most likely for you): <code>{your-environment-id}.live.dynatrace.com</code></li>
<li>Dynatrace-managed tenant: <code>{your-domain}/e/{your-environment-id}</code></li>
</ul>
If running on a Unix/Linux based system, you can use variables for ease of use. Naturally, it is also fine to just replace the values in the <code>kubectl</code> command itself.<pre><code>export DT_TENANT=yourtenant.live.dynatrace.com
export DT_API_TOKEN=yourAPItoken
export DT_PAAS_TOKEN=yourPAAStoken
</code></pre>
<aside class="warning"><p>Please make sure your DT_TENANT does <em>not contain</em> any trailing slashes nor a https:// in the beginning.</p>
</aside>
If you used the variables, the next command can be copied and pasted without modifications. If you have not set the variables, please make sure to set the right values in the next command.<pre><code>oc -n keptn create secret generic dynatrace --from-literal=&#34;DT_API_TOKEN=$DT_API_TOKEN&#34; \
--from-literal=&#34;DT_TENANT=$DT_TENANT&#34; \
--from-literal=&#34;KEPTN_API_URL=http://api-gateway-nginx-keptn.apps-crc.testing/api&#34; \
--from-literal=&#34;KEPTN_API_TOKEN=$KEPTN_API_TOKEN&#34; -o yaml --dry-run=client | oc apply -f -
</code></pre>
</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Deploy Dynatrace OneAgent Operator" duration="0">
        <p>To make the tutorial experience as smooth as possible, we are providing an automation script to setup the Dynatrace OneAgent operator in your Kubernetes cluster. For details on the installation, we refer to the <a href="https://www.dynatrace.com/support/help/technology-support/cloud-platforms/kubernetes/deploy-oneagent-k8/" target="_blank">official Dynatrace documentation</a>. You can download and run the script using the following instructions.</p>
<ol type="1">
<li>Downloading the automation file.<pre><code>curl -o deploy-dynatrace-oneagent.sh https://raw.githubusercontent.com/keptn/examples/release-0.7.2/dynatrace-oneagent/deploy-dynatrace-oneagent-openshift.sh
</code></pre>
</li>
<li>Making the file executable using the <code>chmod</code> command.<pre><code>chmod +x deploy-dynatrace-oneagent.sh
</code></pre>
</li>
<li>Executing the script to automatically deploys the Dynatrace OneAgent Operator.<pre><code>./deploy-dynatrace-oneagent.sh
</code></pre>
</li>
<li>Optional: Verify if all pods in the Dynatrace namespace are running. It might take up to 1-2 minutes for all pods to be up and running.<pre><code>kubectl get pods -n dynatrace
</code></pre>
<pre><code>dynatrace-oneagent-operator-696fd89b76-n9d9n   1/1     Running   0          6m26s
dynatrace-oneagent-webhook-78b6d99c85-h9759    2/2     Running   0          6m25s
oneagent-g9m42                                 1/1     Running   0          69s
</code></pre>
</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Install Dynatrace integration" duration="5">
        <ol type="1">
<li>The Dynatrace integration into Keptn is handled by the <em>dynatrace-service</em>. To install the <em>dynatrace-service</em>, execute:<pre><code>kubectl apply -f https://raw.githubusercontent.com/keptn-contrib/dynatrace-service/0.8.0/deploy/service.yaml
</code></pre>
</li>
<li>When the service is deployed, use the following command to install Dynatrace on your cluster. If Dynatrace is already deployed, the current deployment of Dynatrace will not be modified.<pre><code>keptn configure monitoring dynatrace
</code></pre>
Output should be similar to this:<pre><code>ID of Keptn context: 79f19c36-b718-4bb6-88d5-cb79f163289b
Configuring Dynatrace monitoring
Dynatrace OneAgent Operator is installed on cluster
Setting up auto-tagging rules in Dynatrace Tenant
Tagging rule keptn_service already exists
Tagging rule keptn_stage already exists
Tagging rule keptn_project already exists
Tagging rule keptn_deployment already exists
Setting up problem notifications in Dynatrace Tenant
Checking Keptn alerting profile availability
Keptn alerting profile available
Dynatrace Monitoring setup done
</code></pre>
</li>
</ol>
<p><strong>Verify Dynatrace configuration</strong></p>
<p>Since Keptn has configured your Dynatrace tenant, let us take a look what has be done for you:</p>
<ul>
<li><em>Tagging rules:</em> When you navigate to <strong>Settings &gt; Tags &gt; Automatically applied tags</strong> in your Dynatrace tenant, you will find following tagging rules:<ul>
<li>keptn_deployment</li>
<li>keptn_project</li>
<li>keptn_service</li>
<li>keptn_stage<br><br></li>
</ul>
This means that Dynatrace will automatically apply tags to your onboarded services.</li>
<li><em>Problem notification:</em> A problem notification has been set up to inform Keptn of any problems with your services to allow auto-remediation. You can check the problem notification by navigating to <strong>Settings &gt; Integration &gt; Problem notifications</strong> and you will find a <strong>keptn remediation</strong> problem notification.</li>
<li><em>Alerting profile:</em> An alerting profile with all problems set to <em>0 minutes</em> (immediate) is created. You can review this profile by navigating to <strong>Settings &gt; Alerting &gt; Alerting profiles</strong>.</li>
<li><em>Dashboard and Mangement zone:</em> When creating a new Keptn project or executing the <a href="https://keptn.sh/docs/0.6.0/reference/cli/commands/keptn_configure_monitoring/" target="_blank">keptn configure monitoring</a> command for a particular project (see Note 1), a dashboard and management zone will be generated reflecting the environment as specified in the shipyard file.</li>
</ul>
<aside class="warning"><p>If the nodes in your cluster run on <em>Container-Optimized OS (cos)</em> (default for GKE), the Dynatrace OneAgent might not work properly, the next steps are necessary.</p>
</aside>
<p>Follow the next steps only if your Dynatrace OneAgent does not work properly.</p>
<ol type="1">
<li>To check if the OneAgent does not work properly, the output of <code>kubectl get pods -n dynatrace</code> might look as follows:<pre><code>NAME                                           READY   STATUS             RESTARTS   AGE
dynatrace-oneagent-operator-7f477bf78d-dgwb6   1/1     Running            0          8m21s
oneagent-b22m4                                 0/1     Error              6          8m15s
oneagent-k7jn6                                 0/1     CrashLoopBackOff   6          8m15s
</code></pre>
</li>
<li>This means that after the initial setup you need to edit the OneAgent custom resource in the Dynatrace namespace and add the following entry to the env section:<pre><code>env:
- name: ONEAGENT_ENABLE_VOLUME_STORAGE
  value: &#34;true&#34;
</code></pre>
</li>
<li>To edit the OneAgent custom resource:<pre><code>kubectl edit oneagent -n dynatrace
</code></pre>
</li>
</ol>
<p>At the end of your installation, please verify that all Dynatrace resources are in a Ready and Running status by executing <code>kubectl get pods -n dynatrace</code>:</p>
<pre><code>NAME                                           READY   STATUS       RESTARTS   AGE
dynatrace-oneagent-operator-7f477bf78d-dgwb6   1/1     Running      0          8m21s
oneagent-b22m4                                 1/1     Running      0          8m21s
oneagent-k7jn6                                 1/1     Running      0          8m21s
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Configure Dynatrace with Keptn" duration="0">
        <ol type="1">
<li>Checkout the examples repository that holds the scripts to get started easily.<pre><code>git clone --branch release-0.7.1 https://github.com/keptn/examples
</code></pre>
</li>
<li><pre><code>oc -n keptn create secret generic dynatrace --from-literal=&#34;DT_API_TOKEN=$DT_API_TOKEN&#34; \
  --from-literal=&#34;DT_TENANT=$DT_TENANT&#34; \
  --from-literal=&#34;KEPTN_API_URL=http://api-gateway-nginx-keptn.apps-crc.testing/api&#34; \
  --from-literal=&#34;KEPTN_API_TOKEN=$KEPTN_API_TOKEN&#34; -o yaml --dry-run=client | oc apply -f -
</code></pre>
<pre><code>oc apply -f https://raw.githubusercontent.com/keptn-contrib/dynatrace-service/0.8.0/deploy/service.yaml
</code></pre>
<pre><code>keptn configure monitoring dynatrace --suppress-websocket
</code></pre>
</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Create your first project" duration="5">
        <p>A project in Keptn is the logical unit that can hold multiple (micro)services. Therefore, it is the starting point for each Keptn installation.</p>
<p>To get all files you need for this tutorial, please clone the example repo to your local machine.</p>
<pre><code>git clone --branch release-0.7.0 https://github.com/keptn/examples.git --single-branch

cd examples/onboarding-carts
</code></pre>
<p>Create a new project for your services using the <code>keptn create project</code> command. In this example, the project is called <em>sockshop</em>. Before executing the following command, make sure you are in the <code>examples/onboarding-carts</code> folder.</p>
<p><strong>Recommended:</strong> Create a new project with Git upstream:</p>
<p>To configure a Git upstream for this tutorial, the Git user (<code>--git-user</code>), an access token (<code>--git-token</code>), and the remote URL (<code>--git-remote-url</code>) are required. If a requirement is not met, go to <a href="https://keptn.sh/docs/0.7.0/manage/git_upstream/" target="_blank">the Keptn documentation</a> where instructions for GitHub, GitLab, and Bitbucket are provided.</p>
<p>Let&#39;s define the variables before running the command:</p>
<pre><code>GIT_USER=gitusername
GIT_TOKEN=gittoken
GIT_REMOTE_URL=remoteurl
</code></pre>
<p>Now let&#39;s create the project using the <code>keptn create project</code> command.</p>
<pre><code>keptn create project sockshop --shipyard=./shipyard.yaml --git-user=$GIT_USER --git-token=$GIT_TOKEN --git-remote-url=$GIT_REMOTE_URL
</code></pre>
<p><strong>Alternatively:</strong> If you don&#39;t want to use a Git upstream, you can create a new project without it but please note that this is not the recommended way:</p>
<pre><code>keptn create project sockshop --shipyard=./shipyard.yaml
</code></pre>
<p>For creating the project, the tutorial relies on a <code>shipyard.yaml</code> file as shown below:</p>
<pre><code>stages:
  - name: &#34;dev&#34;
    deployment_strategy: &#34;direct&#34;
    test_strategy: &#34;functional&#34;
  - name: &#34;staging&#34;
    approval_strategy: 
      pass: &#34;automatic&#34;
      warning: &#34;automatic&#34;
    deployment_strategy: &#34;blue_green_service&#34;
    test_strategy: &#34;performance&#34;
  - name: &#34;production&#34;
    approval_strategy: 
      pass: &#34;automatic&#34;
      warning: &#34;manual&#34;
    deployment_strategy: &#34;blue_green_service&#34;
    remediation_strategy: &#34;automated&#34;
</code></pre>
<p>This shipyard contains three stages: dev, staging, and production. This results in the three Kubernetes namespaces: sockshop-dev, sockshop-staging, and sockshop-production.</p>
<ul>
<li><strong>dev</strong> will have a direct (big bang) deployment strategy and functional tests are executed</li>
<li><strong>staging</strong> will have a blue/green deployment strategy with automated approvals for passing quality gates as well as quality gates which result in warnings. As configured, performance tests are executed.</li>
<li><strong>production</strong> will have a blue/green deployment strategy without any further testing. Approvals are done automatically for passed quality gates but manual approval is needed for quality gate evaluations that result in a warning. The configured remediation strategy is used for self-healing in production.</li>
</ul>
<aside class="special"><p>To learn more about a <em>shipyard</em> file, please take a look at the <a href="https://github.com/keptn/spec/blob/master/shipyard.md" target="_blank">Shipyard specification</a>.</p>
</aside>
<p>Let&#39;s take a look at the project that we have just created. We can find all this information in the Keptn&#39;s Bridge.<br>Therefore, we need the credentials that have been automatically generated for us.</p>
<pre><code>keptn configure bridge --output
</code></pre>
<p>Now use these credentials to access it on your Keptn endpoint.</p>
<pre><code>echo http://$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)/bridge
</code></pre>
<p>You will find the just created project in the bridge with all stages.<br><img alt="bridge" src="img/ea75605185cd741f.png"><img alt="bridge" src="img/d3919622be13ae7c.png"></p>
<p>// TODO GET SERVICE URL AND GET BRIDGE URL</p>


      </google-codelab-step>
    
      <google-codelab-step label="Onboard first microservice" duration="5">
        <p>After creating the project, services can be onboarded to our project.</p>
<ol type="1">
<li>Onboard the <strong>carts</strong> service using the <a href="https://keptn.sh/docs/0.7.x/reference/cli/commands/keptn_onboard_service/" target="_blank">keptn onboard service</a> command:<pre><code>keptn onboard service carts --project=sockshop --chart=./carts
</code></pre>
</li>
<li>After onboarding the service, tests (i.e., functional- and performance tests) need to be added as basis for quality gates in the different stages:<ul>
<li>Functional tests for <em>dev</em> stage:</li>
</ul>
<pre><code>keptn add-resource --project=sockshop --stage=dev --service=carts --resource=jmeter/basiccheck.jmx --resourceUri=jmeter/basiccheck.jmx
</code></pre>
<ul>
<li>Performance tests for <em>staging</em> stage:</li>
</ul>
<pre><code>keptn add-resource --project=sockshop --stage=staging --service=carts --resource=jmeter/load.jmx --resourceUri=jmeter/load.jmx
</code></pre>
<strong>Note:</strong> You can adapt the tests in <code>basiccheck.jmx</code> as well as <code>load.jmx</code> for your service. However, you must not rename the files because there is a hardcoded dependency on these file names in the current implementation of Keptn&#39;s jmeter-service.</li>
</ol>
<p>Since the carts service requires a mongodb database, a second service needs to be onboarded.</p>
<ul>
<li>Onboard the <strong>carts-db</strong> service using the <a href="https://keptn.sh/docs/0.7.x/reference/cli/commands/keptn_onboard_service/" target="_blank">keptn onboard service</a> command. The <code>--deployment-strategy</code> flag specifies that for this service a <em>direct</em> deployment strategy in all stages should be used regardless of the deployment strategy specified in the shipyard. Thus, the database is not blue/green deployed.<pre><code>keptn onboard service carts-db --project=sockshop --chart=./carts-db --deployment-strategy=direct
</code></pre>
</li>
</ul>
<p>Take a look in your Keptn&#39;s Bridge and see the newly onboarded services.<br><img alt="bridge services" src="img/33106f7456894b04.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Deploy first build with Keptn" duration="5">
        <p>After onboarding the services, a built artifact of each service can be deployed.</p>
<ol type="1">
<li>Deploy the carts-db service by executing the <a href="https://keptn.sh/docs/0.7.x/reference/cli/commands/keptn_send_event_new-artifact/" target="_blank">keptn send event new-artifact</a> command:<pre><code>keptn send event new-artifact --project=sockshop --service=carts-db --image=docker.io/mongo --tag=4.2.2
</code></pre>
</li>
<li>Deploy the carts service by specifying the built artifact, which is stored on DockerHub and tagged with version 0.11.1:<pre><code>keptn send event new-artifact --project=sockshop --service=carts --image=docker.io/keptnexamples/carts --tag=0.11.1
</code></pre>
</li>
<li>Go to Keptn&#39;s Bridge and check which events have already been generated.<br><img alt="bridge" src="img/5a1640c50f69de79.png"></li>
<li><strong>Optional:</strong> Verify the pods that should have been created for services carts and carts-db:<pre><code>kubectl get pods --all-namespaces | grep carts-
</code></pre>
<pre><code>sockshop-dev          carts-77dfdc664b-25b74                            1/1     Running     0          10m
sockshop-dev          carts-db-54d9b6775-lmhf6                          1/1     Running     0          13m
sockshop-production   carts-db-54d9b6775-4hlwn                          2/2     Running     0          12m
sockshop-production   carts-primary-79bcc7c99f-bwdhg                    2/2     Running     0          2m15s
sockshop-staging      carts-db-54d9b6775-rm8rw                          2/2     Running     0          12m
sockshop-staging      carts-primary-79bcc7c99f-mbbgq                    2/2     Running     0          7m24s
</code></pre>
</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="View carts service" duration="2">
        <ol type="1">
<li>Get the URL for your carts service with the following commands in the respective namespaces:<pre><code>echo http://carts.sockshop-dev.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
<pre><code>echo http://carts.sockshop-staging.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
<pre><code>echo http://carts.sockshop-production.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
</li>
<li>Navigate to the URLs to inspect the carts service. In the production namespace, you should receive an output similar to this:</li>
</ol>
<p class="image-container"><img alt="carts in production" src="img/da8218ae54b69582.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Generate traffic" duration="2">
        <p>Now that the service is running in all three stages, let us generate some traffic so we have some data we can base the evaluation on.</p>
<p>Change the directory to <code>examples/load-generation/cartsloadgen</code>. If you are still in the onboarding-carts directory, use the following command or change it accordingly:</p>
<pre><code>cd ../load-generation/cartsloadgen
</code></pre>
<p>Now let us deploy a pod that will generate some traffic for all three stages of our demo environment.</p>
<pre><code>kubectl apply -f deploy/cartsloadgen-base.yaml 
</code></pre>
<p>The output will look similar to this.</p>
<pre><code>namespace/loadgen created
deployment.extensions/cartsloadgen created
</code></pre>
<p>Optionally, you can verify that the load generator has been started.</p>
<pre><code>kubectl get pods -n loadgen
</code></pre>
<pre><code>NAME                            READY   STATUS    RESTARTS   AGE
cartsloadgen-5dc47c85cf-kqggb   1/1     Running   0          117s
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Set up the quality gate" duration="4">
        <p>Keptn requires a performance specification for the quality gate. This specification is described in a file called <code>slo.yaml</code>, which specifies a Service Level Objective (SLO) that should be met by a service. To learn more about the <em>slo.yaml</em> file, go to <a href="https://github.com/keptn/spec/blob/master/service_level_objective.md" target="_blank">Specifications for Site Reliability Engineering with Keptn</a>.</p>
<p>Activate the quality gates for the carts service. Therefore, navigate to the <code>examples/onboarding-carts</code> folder and upload the <code>slo-quality-gates.yaml</code> file using the <a href="https://keptn.sh/docs/0.7.x/reference/cli/commands/keptn_add-resource/" target="_blank">add-resource</a> command:</p>
<p>Make sure you are in the correct folder <code>examples/onboarding-carts</code>. If not, change the directory accordingly, e.g., <code>cd ../../onboarding-carts</code>.</p>
<pre><code>keptn add-resource --project=sockshop --stage=staging --service=carts --resource=slo-quality-gates.yaml --resourceUri=slo.yaml
</code></pre>
<p>This will add the <code>SLO.yaml</code> file to your Keptn - which is the declaritive definition of a quality gate. Let&#39;s take a look at the file contents:</p>
<pre><code>---
spec_version: &#34;1.0&#34;
comparison:
  aggregate_function: &#34;avg&#34;
  compare_with: &#34;single_result&#34;
  include_result_with_score: &#34;pass&#34;
  number_of_comparison_results: 1
filter:
objectives:
  - sli: &#34;response_time_p95&#34;
    key_sli: false
    pass:             # pass if (relative change &lt;= 10% AND absolute value is &lt; 600ms)
      - criteria:
          - &#34;&lt;=+10%&#34;  # relative values require a prefixed sign (plus or minus)
          - &#34;&lt;600&#34;    # absolute values only require a logical operator
    warning:          # if the response time is below 800ms, the result should be a warning
      - criteria:
          - &#34;&lt;=800&#34;
    weight: 1
total_score:
  pass: &#34;90%&#34;
  warning: &#34;75%&#34;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Verify current version" duration="3">
        <p>You can take a look at the currently deployed version of our &#34;carts&#34; microservice before we deploy the next build of our microservice.</p>
<ol type="1">
<li>Get the URL for your carts service with the following commands in the respective stages:<pre><code>echo http://carts.sockshop-dev.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
<pre><code>echo http://carts.sockshop-staging.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
<pre><code>echo http://carts.sockshop-production.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
</li>
<li>Navigate to <code>http://carts.sockshop-production.YOUR.DOMAIN</code> for viewing the carts service in your <strong>production</strong> environment and you should receive an output similar to the following:</li>
</ol>
<p class="image-container"><img alt="carts service" src="img/da8218ae54b69582.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Deploy a slow build version" duration="5">
        <ol type="1">
<li>Use the Keptn CLI to deploy a version of the carts service, which contains an artificial <strong>slowdown of 1 second</strong> in each request.<pre><code>keptn send event new-artifact --project=sockshop --service=carts --image=docker.io/keptnexamples/carts --tag=0.11.2
</code></pre>
</li>
<li>Go ahead and verify that the slow build has reached your <code>dev</code> and <code>staging</code> environments by opening a browser for both environments. Get the URLs with these commands:<pre><code>echo http://carts.sockshop-dev.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
<pre><code>echo http://carts.sockshop-staging.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
</li>
</ol>
<p class="image-container"><img alt="carts service" src="img/ac48a3cf213a8050.png"></p>
<p class="image-container"><img alt="carts service" src="img/e5cfc05c6bd13efb.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Quality gate in action" duration="7">
        <p>After triggering the deployment of the carts service in version v0.11.2, the following status is expected:</p>
<ul>
<li><strong>Dev stage:</strong> The new version is deployed in the dev stage and the functional tests passed.<ul>
<li>To verify, open a browser and navigate to:<br><pre><code>echo http://carts.sockshop-dev.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
</li>
</ul>
</li>
<li><strong>Staging stage:</strong> In this stage, version v0.11.2 will be deployed and the performance test starts to run for about 10 minutes. After the test is completed, Keptn triggers the test evaluation and identifies the slowdown. Consequently, a roll-back to version v0.11.1 in this stage is conducted and the promotion to production is not triggered.</li>
<li><strong>Production stage:</strong> The slow version is <strong>not promoted</strong> to the production stage because of the active quality gate in place. Thus, still version v0.11.1 is expected to be in production.<ul>
<li>To verify, navigate to:<br><pre><code>echo http://carts.sockshop-production.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
</li>
</ul>
</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Verify the quality gate in Keptn&#39;s Bridge" duration="3">
        <p>Take a look in the Keptn&#39;s bridge and navigate to the last deployment. You will find a quality gate evaluation that got a <code>fail</code> result when evaluation the SLOs of our carts microservice. Thanks to this quality gate the slow build won&#39;t be promoted to production but instead automatically rolled back.</p>
<p>To verify, the <a href="https://keptn.sh/docs/0.7.x/reference/bridge/" target="_blank">Keptn&#39;s Bridge</a> shows the deployment of v0.11.2 and then the failed test in staging including the roll-back.</p>
<p class="image-container"><img alt="Keptn's bridge" src="img/f80e40846609edcd.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Deploy a regular carts version" duration="3">
        <ol type="1">
<li>Use the Keptn CLI to send a new version of the <em>carts</em> artifact, which does <strong>not</strong> contain any slowdown:<pre><code>keptn send event new-artifact --project=sockshop --service=carts --image=docker.io/keptnexamples/carts --tag=0.11.3
</code></pre>
</li>
<li>To verify the deployment in <em>production</em> (it may take a couple of minutes), open a browser and navigate to the carts service in your production environment. As a result, you see <code>Version: v3</code>.</li>
<li>Besides, you can verify the deployments in your Kubernetes cluster using the following commands:<pre><code>kubectl get deployments -n sockshop-production
</code></pre>
<pre><code>NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
carts-db        1         1         1            1           63m
carts-primary   1         1         1            1           98m
</code></pre>
<pre><code>kubectl describe deployment carts-primary -n sockshop-production
</code></pre>
<pre><code>...
Pod Template:
Labels:  app=carts-primary
Containers:
  carts:
    Image:      docker.io/keptnexamples/carts:0.11.3
</code></pre>
</li>
<li>Take another look into the Keptn&#39;s Bridge and you will see this new version passed the quality gate and thus, is now running in production!</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Self-healing with feature flags" duration="2">
        <p>Next, you will learn how to use the capabilities of Keptn to provide self-healing for an application with feature flags based on the <a href="https://unleash.github.io/" target="_blank">Unleash feature toggle framework</a>.</p>
<aside class="special"><p>For the sake of this tutorial, we will onboard Unleash as a Keptn project. The carts microservice is already pre-configured for this.</p>
</aside>
<p>To quickly get an Unleash server up and running with Keptn, follow these instructions:</p>
<ol type="1">
<li>Make sure you are in the correct folder of your examples directory:<pre><code>cd examples/unleash-server
</code></pre>
</li>
<li>Create a new project using the <code>keptn create project</code> command:<pre><code>keptn create project unleash --shipyard=./shipyard.yaml
</code></pre>
</li>
<li>Onboard unleash and unleash-db using the <code>keptn onboard service</code> command:<pre><code>keptn onboard service unleash-db --project=unleash --chart=./unleash-db
keptn onboard service unleash --project=unleash --chart=./unleash
</code></pre>
</li>
<li>Send new artifacts for unleash and unleash-db using the <code>keptn send new-artifact</code> command:<pre><code>keptn send event new-artifact --project=unleash --service=unleash-db --image=postgres:10.4
keptn send event new-artifact --project=unleash --service=unleash --image=docker.io/keptnexamples/unleash:1.0.0
</code></pre>
</li>
<li>Get the URL (<code>unleash.unleash-dev.KEPTN_DOMAIN</code>):<pre><code>echo http://unleash.unleash-dev.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;)
</code></pre>
</li>
<li>Open the URL in your browser and log in using the following credentials:<ul>
<li>Username: keptn</li>
<li>Password: keptn</li>
</ul>
</li>
</ol>
<p>You should be able to login using the credentials <em>keptn/keptn</em>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Configure the Unleash server" duration="4">
        <p>In this tutorial, we are going to introduce feature toggles for two scenarios:</p>
<ol type="1">
<li>Feature flag for a very simple caching mechanism that can speed up the delivery of the website since it skips the calls to the database but instead replies with static content.</li>
<li>Feature flag for a promotional campaign that can be enabled whenever you want to run a promotional campaign on top of your shopping cart.</li>
</ol>
<p>To set up both feature flags, please use the following scripts to automatically generate the feature flags that we need in this tutorial.</p>
<pre><code>export UNLEASH_TOKEN=$(echo -n keptn:keptn | base64)
export UNLEASH_BASE_URL=$(echo http://unleash.unleash-dev.$(kubectl -n keptn get ingress api-keptn-ingress -ojsonpath=&#39;{.spec.rules[0].host}&#39;))

curl --request POST \
  --url ${UNLEASH_BASE_URL}/api/admin/features/ \
  --header &#34;authorization: Basic ${UNLEASH_TOKEN}&#34; \
  --header &#39;content-type: application/json&#39; \
  --data &#39;{
  &#34;name&#34;: &#34;EnableItemCache&#34;,
  &#34;description&#34;: &#34;carts&#34;,
  &#34;enabled&#34;: false,
	&#34;strategies&#34;: [
    {
      &#34;name&#34;: &#34;default&#34;,
      &#34;parameters&#34;: {}
    }
  ]
}&#39;

curl --request POST \
  --url ${UNLEASH_BASE_URL}/api/admin/features/ \
  --header &#34;authorization: Basic ${UNLEASH_TOKEN}&#34; \
  --header &#39;content-type: application/json&#39; \
  --data &#39;{
  &#34;name&#34;: &#34;EnablePromotion&#34;,
  &#34;description&#34;: &#34;carts&#34;,
  &#34;enabled&#34;: false,
	&#34;strategies&#34;: [
    {
      &#34;name&#34;: &#34;default&#34;,
      &#34;parameters&#34;: {}
    }
  ]
}&#39;
</code></pre>
<h2 is-upgraded>Optionally verify the generated feature flags</h2>
<p>If you want to verify the feature flags that have been created, please login to your Unleash server - or if you are already logged in - refresh the browser.</p>
<p class="image-container"><img alt="unleash" src="img/aaf471f8a5480223.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Configure Keptn" duration="5">
        <p>Now, everything is set up in the Unleash server. For Keptn to be able to connect to the Unleash server, we have to add a secret with the Unleash API URL as well as the Unleash tokens.</p>
<ol type="1">
<li>In order for Keptn to be able to use the Unleash API, we need to add the credentials as a secret to our Keptn namespace. In this tutorial, we do not have to change the values for UNLEASH_SERVER, UNLEASH_USER, and UNLEASH_TOKEN, but in your own custom scenario this might be needed to change it to your actual Unleash URL, user and token.<br>As said, in this tutorial we can use the following command as it is:<pre><code>kubectl -n keptn create secret generic unleash --from-literal=&#34;UNLEASH_SERVER_URL=http://unleash.unleash-dev/api&#34; --from-literal=&#34;UNLEASH_USER=keptn&#34; --from-literal=&#34;UNLEASH_TOKEN=keptn&#34;
</code></pre>
</li>
<li>Install the Unleash action provider which is responsible for acting upon an alert, thus it is the part that will actually resolve issues by changing the stage of the feature flags.<pre><code>kubectl apply -f https://raw.githubusercontent.com/keptn-contrib/unleash-service/release-0.1.0/deploy/service.yaml
</code></pre>
</li>
<li>Switch to the carts example (<code>cd examples/onboarding-carts</code>) and add the following remediation instructions<pre><code>apiVersion: spec.keptn.sh/0.1.4
kind: Remediation
metadata:
  name: carts-remediation
spec:
  remediations:
    - problemType: Response time degradation
      actionsOnOpen:
        - action: toggle-feature
          name: Toogle feature flag
          description: Toogle feature flag EnableItemCache to ON
          value:
            EnableItemCache: &#34;on&#34;
    - problemType: Failure rate increase
      actionsOnOpen:
        - action: toggle-feature
          name: Toogle feature flag
          description: Toogle feature flag EnablePromotion to OFF
          value:
            EnablePromotion: &#34;off&#34;
</code></pre>
using the following command. Please make sure you are in the correct folder <code>examples/onboarding-carts</code>.<pre><code>keptn add-resource --project=sockshop --service=carts --stage=production --resource=remediation_feature_toggle.yaml --resourceUri=remediation.yaml
</code></pre>
<strong>Note:</strong> The file describes remediation actions (e.g., <code>featuretoggle</code>) in response to problems/alerts (e.g., <code>Response time degradation</code>) that are sent to Keptn.</li>
<li>We are also going to add an SLO file so that Keptn can evaluate if the remediation action was successful.<br><pre><code>keptn add-resource --project=sockshop --stage=production --service=carts --resource=slo-self-healing.yaml --resourceUri=slo.yaml
</code></pre>
</li>
<li>Start the load generation script for this use case:<br><pre><code>kubectl apply -f ../load-generation/cartsloadgen/deploy/cartsloadgen-prod.yaml
</code></pre>
</li>
</ol>
<p>Now that everything is set up, next we are going to hit the application with some load and toggle the feature flags.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Run the experiment" duration="5">
        <ol type="1">
<li>In this tutorial, we are going to turn on the promotional campaign, which purpose is to add promotional gifts to about 30 % of the user interactions that put items in their shopping cart.</li>
<li>Click on the toggle next to <strong>EnablePromotion</strong> to enable this feature flag.<img alt="enable-toggle" src="img/6f3e8427811d68eb.png"></li>
<li>By enabling this feature flag, a not implemented function is called resulting in a <em>NotImplementedFunction</em> error in the source code and a failed response. After a couple of minutes, the monitoring tool will detect an increase in the failure rate and will send out a problem notification to Keptn.</li>
<li>Keptn will receive the problem notification/alert and look for a remediation action that matches this problem. Since we have added the <code>remediation.yaml</code> before, Keptn will find a remediation action and will trigger the corresponding action by reaching out to the action provider that will disable the feature flag.</li>
<li>Finally, take a look into the Keptn&#39;s Bridge to see that an open problem has been resolved. You might notice that also the other stages like <em>dev</em>, and <em>staging</em> received the error. The reason is that they all receive the same feature flag configuration and all receive traffic from the load generator. However, for <em>dev</em> and <em>staging</em> there is no <code>remediation.yaml</code> added and thus, no remediation will be performed if problems in this stages are detected. If you want to change this behaviour, go ahead and also add the <code>remediation.yaml</code> file to the other stages by executing another <code>keptn add-resource</code> command. For this tutorial, we are fine by only having self-healing for our production stage!<img alt="bridge unleash" src="img/1df3e550e581fc9a.png"></li>
<li>10 minutes after Keptn disables the feature flag, Keptn will also trigger another evaluation to make sure the trigger remediation action did actually resolve the problem. In case the problem is not resolved and the remediation file would hold more remediation actions, Keptn would go ahead and trigger them. For our tutorial Keptn has resolved the issue already, so no need for a second try!</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Feedback" duration="0">
        <aside class="special"><p>We are happy to hear your feedback!</p>
</aside>
<p>Please visit us in our <a href="https://slack.keptn.sh" target="_blank">Keptn Slack</a> and tell us how you like Keptn and this tutorial! We are happy to hear your thoughts &amp; suggestions!</p>
<p>Also, make sure to <a href="https://twitter.com/keptnProject" target="_blank">follow us on Twitter</a> to get the latest news on Keptn, our tutorials and newest releases!</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
